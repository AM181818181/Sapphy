<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Small Black Dog: Find My Sister</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --w:1920; --h:1080; }
  html, body { margin:0; height:100%; background:#000; }
  #stage { position: fixed; inset: 0; display: grid; place-items: center; background:#000; }
  canvas { width: var(--w)px; height: var(--h)px; background:#000; display:block; }

  .ui {
    position: fixed; left:50%; transform:translateX(-50%);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:#fff; text-shadow: 2px 2px 2px rgba(0,0,0,.85);
    pointer-events:none; max-width: 88vw;
  }
  #bubbleDog { position: fixed; display:none; font-size:26px; background:rgba(0,0,0,.5);
               padding:10px 14px; border-radius:12px; }
  #centerMsg { top: 48%; transform: translate(-50%,-50%); font-size: 50px; font-weight: 800;
               text-align:center; display:none; }
  #tooltip { bottom:5%; background:rgba(0,0,0,.75); padding:10px 14px; border-radius:12px; font-size:22px; display:none; }

  /* Final text: start invisible; fade in when we set opacity=1 a few seconds after final image shows */
  #endText {
    top: 8%; transform:translateX(-50%);
    font-size:48px; font-weight:800; opacity:0; transition: opacity 1.4s ease;
  }

  #splashHelp { position: fixed; inset: 0; display:none; place-items:end center; padding:2rem; }
  #splashHelp .card{
    background: rgba(0,0,0,.55); padding:16px 20px; border-radius:14px; line-height:1.45;
    font: 18px system-ui; color:#fff; text-align:center;
  }

  #introWrap { position: fixed; inset:0; display:none; place-items:center; background:#000; }
  #introWrap video { max-width: 100vw; max-height: 100vh; outline: none; border:none; }
</style>
</head>
<body>
<div id="stage">
  <canvas id="game" width="1920" height="1080"></canvas>
</div>

<!-- UI overlays -->
<div id="bubbleDog" class="ui"></div>
<div id="centerMsg" class="ui"></div>
<div id="tooltip" class="ui"></div>
<div id="endText" class="ui">Finally, she's home!</div>

<!-- Splash instructions -->
<div id="splashHelp">
  <div class="card">
    <div style="font-size:26px;margin-bottom:8px;">Small Black Dog: Find My Sister</div>
    <div style="margin-bottom:8px;"><b>A / D</b> — Move • <b>S</b> — Sniff • <b>B</b> — Bark • <b>H</b> — Howl</div>
    <div style="opacity:.95;">Press <b>SPACE</b> to start</div>
  </div>
</div>

<!-- Intro video -->
<div id="introWrap">
  <video id="introVid" src="introvideo.mp4" poster="splashscreen.png" playsinline muted></video>
</div>

<script>
/* =========================
   Canvas + Fit-to-Window
========================= */
const W = 1920, H = 1080;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function fit() {
  const sw = window.innerWidth, sh = window.innerHeight;
  const scale = Math.min(sw / W, sh / H);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', fit); fit();

/* =========================
   UI helpers
========================= */
const bubbleDog = document.getElementById('bubbleDog');
const centerMsg = document.getElementById('centerMsg');
const tooltipEl = document.getElementById('tooltip');
const endTextEl = document.getElementById('endText');
const splashHelp = document.getElementById('splashHelp');

function showCenter(text, ms=4000) {
  centerMsg.textContent = text; centerMsg.style.display='block';
  if (ms) setTimeout(()=> centerMsg.style.display='none', ms);
}
function showTooltip(text, ms=4000) {
  tooltipEl.textContent = text; tooltipEl.style.display='block';
  if (ms) setTimeout(()=> tooltipEl.style.display='none', ms);
}
function showDogBubble(text, ms=3500) {
  bubbleDog.textContent = text;
  const r = canvas.getBoundingClientRect();
  const px = r.left + (dog.x + dog.w*0.5) * (r.width / W);
  const py = r.top + (dog.y - 30) * (r.height / H);
  bubbleDog.style.left = px + 'px';
  bubbleDog.style.top  = py + 'px';
  bubbleDog.style.transform = 'translate(-50%,-100%)';
  bubbleDog.style.display='block';
  if (ms) setTimeout(()=> bubbleDog.style.display='none', ms);
}

/* =========================
   Assets
========================= */
const images = {};
const imageFiles = [
  "splashscreen.png","lvl1.png","lvl1dooropen.png","lvl2.png","finalscreen.png",
  "sit.png","walk1.png","walk2.png","walk3.png","sniff1.png","howl.png",
  "treat1.png","treat2.png"
];
function loadImages(files, cb){
  let left = files.length; if (!left) return cb();
  files.forEach(name=>{
    const img = new Image();
    img.onload = done; img.onerror = (e)=>{ console.warn("Image failed:", name); done(); };
    img.src = name; images[name]=img;
  });
  function done(){ if (--left===0) cb(); }
}

// Audio (BGM quiet; SFX loud)
const sounds = {
  bgm: new Audio(encodeURI("BGMUSIC.mp3")),
  final: new Audio(encodeURI("final music.mp3")),
  sniff1: new Audio(encodeURI("Sniff1.m4a")),
  sniff2: new Audio(encodeURI("sniff2.m4a")),
  bark: new Audio(encodeURI("bark1.m4a")),
  howl1: new Audio(encodeURI("howl1.m4a")),
  howl2: new Audio(encodeURI("howl2.m4a")),
  pickup: new Audio(encodeURI("treatpickup.m4a")),
  dooropen: new Audio(encodeURI("dooropen.wav")),
  knock: new Audio(encodeURI("door knock.wav")),
  letout: new Audio(encodeURI("letoutvoice.m4a")),
  rain: new Audio(encodeURI("rain.wav"))
};
const MUSIC_BASE = 0.35; // quiet BGM
sounds.bgm.loop = true; sounds.bgm.volume = MUSIC_BASE;
sounds.final.loop = false;

/* =========================
   Input
========================= */
const keys = {};
window.addEventListener('keydown', e=> { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup',   e=> { keys[e.key.toLowerCase()] = false; });

/* =========================
   Game State
========================= */
let scene = "splash";
let bg = null;
const dog = { x:220, y:680, w:450, h:400, state:"sit", dir:1, walkFrame:0, walkTimer:0, walkSpeed:0.1 };
let drawDogFlag = true; // NEW: allow hiding dog during transitions

let treatActive=false, treatX=1200, treatY=820, treatImg="treat1.png";
let sniffPresses=0, loopsDone=0;
let autoSeek=false, autoRunOff=false, autoRunIn=false;
let callDadCount=0, actionCountL2=0;
let bgmPlaying=false;
let sniffGate=false, barkGate=false, howlGate=false;

/* =========================
   Audio control + Exclusive VO (dip BGM to 10%)
========================= */
function duckBGM(dbDown, ms){
  const linear = Math.pow(10, dbDown/20);
  const target = Math.max(0, Math.min(1, sounds.bgm.volume * linear));
  sounds.bgm.volume = target;
  setTimeout(()=> sounds.bgm.volume = MUSIC_BASE, (ms||400));
}
let sfxLock = false;
function playSfx(snd, duckDb=-4, holdMs=null, volOverride=1.0){
  if (!snd || sfxLock) return;
  try {
    snd.volume = volOverride;
    snd.currentTime = 0;
    const ms = holdMs ?? Math.max(220, (snd.duration||0.4)*1000);
    duckBGM(duckDb, ms+380);
    snd.play().catch(()=>{});
  }catch(e){ console.warn("SFX error", e); }
}
/* VO exclusive: BGM dips to 10%, other SFX locked */
function playExclusiveVO(snd, after){
  if (!snd) return;
  sfxLock = true;
  const restoreVol = MUSIC_BASE;
  sounds.bgm.volume = 0.10; // dip to 10%
  try{ sounds.rain.pause(); }catch{}
  for (const k in sounds){
    if (sounds[k] !== snd && k!=='final' && k!=='bgm'){
      try{ sounds[k].pause(); }catch{}
    }
  }
  try{
    snd.volume = 1.0; snd.currentTime = 0; snd.play().catch(()=>{});
    snd.onended = ()=>{
      sfxLock = false;
      sounds.bgm.volume = restoreVol;
      if (typeof after === 'function') after();
    };
  }catch(e){ sfxLock=false; sounds.bgm.volume = restoreVol; if (typeof after==='function') after(); }
}
function playBGM(){ if(!bgmPlaying){ sounds.bgm.play().then(()=>bgmPlaying=true).catch(()=>{}); } }
function stopBGM(){ try{ sounds.bgm.pause(); bgmPlaying=false; }catch{} }

/* =========================
   Scenes
========================= */
const introWrap = document.getElementById('introWrap');
const introVid  = document.getElementById('introVid');

function startLevel1(){
  scene = "level1_sniff";
  bg = images["lvl1.png"];
  Object.assign(dog, { x:220,y:680,state:"sit",dir:1,walkFrame:0,walkTimer:0 });
  drawDogFlag = true;
  treatActive=autoSeek=autoRunOff=autoRunIn=false;
  sniffPresses=0; loopsDone=0; callDadCount=0;
  showCenter("I can smell something good!", 4000);
  showCenter("Press S to sniff for more treats", 4000);
}
function startLevel1_CallDad(){
  scene = "level1_call";
  showCenter("Sapphy wants to go outside", 4000);
  showTooltip("Bark (B) or Howl (H) a few times", 4000);
  callDadCount = 0;
}
function startLevel2(){
  scene = "level2";
  bg = images["lvl2.png"];
  try{ sounds.rain.pause(); }catch{}
  Object.assign(dog, { x:220,y:680,state:"sit",dir:1,walkFrame:0,walkTimer:0 });
  drawDogFlag = true; // show dog again in L2
  actionCountL2=0;
  playBGM();
  showCenter("Where is my favourite person, I should bark!", 4000);
  showTooltip("Bark (B) or Howl (H) 8 times", 4000);
}
function startFinal(){
  scene = "final";
  stopBGM();
  bg = images["finalscreen.png"];   // fully cover canvas each frame
  // fade-in end text after 3s
  setTimeout(()=>{ endTextEl.style.opacity = 1; }, 3000);
  try{ sounds.final.currentTime=0; sounds.final.play(); }catch{}
}

/* =========================
   Treat Flow Helpers
========================= */
function setWalk(fast=false){ if(dog.state!=="walk"){ dog.state="walk"; dog.walkFrame=0; dog.walkTimer=0; } dog.walkSpeed = fast?0.06:0.1; }
function spawnTreatAwayFromDog(){
  treatImg = Math.random()<0.5 ? "treat1.png" : "treat2.png";
  const minOffset=300, maxOffset=700;
  let x = dog.x + (minOffset + Math.random()*(maxOffset-minOffset));
  x = Math.max(380, Math.min(W-500, x));
  treatX = Math.floor(x); treatY = 820;
  treatActive = true; autoSeek = true;
}
function pickupTreat(){
  treatActive=false; autoSeek=false;
  playSfx(sounds.pickup, -4, null, 1.0);
  autoRunOff = true;
  setTimeout(()=> showDogBubble("I'll save this for later.", 4000), 250);
}

/* =========================
   Level Updates
========================= */
function level1SniffUpdate(dt){
  const canMove = !autoSeek && !autoRunOff && !autoRunIn;
  const speed = 280 * dt;
  if (canMove) {
    if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
    else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
    else if (dog.state==="walk") dog.state="sit";
    dog.x = Math.max(40, Math.min(W-500, dog.x));
  }
  if (!sfxLock && keys['s'] && !sniffGate && canMove){
    sniffGate=true; dog.state="sniff";
    playSfx(Math.random()<0.5?sounds.sniff1:sounds.sniff2, -4, null, 1.0);
    sniffPresses++;
    setTimeout(()=>{ sniffGate=false; dog.state="sit"; }, 260);
    if (sniffPresses>=3 && !treatActive){ sniffPresses=0; spawnTreatAwayFromDog(); }
  }
  if (autoSeek && treatActive){
    const target = treatX - 80;
    const dir = (dog.x < target) ? 1 : -1;
    dog.dir = dir; setWalk();
    dog.x += (300*dt) * dir;
    if ((dir>0 && dog.x >= target) || (dir<0 && dog.x <= target)) { dog.state="sit"; pickupTreat(); }
  }
  if (autoRunOff){
    setWalk(true); dog.dir=1; dog.x += (480*dt);
    if (dog.x > W + 120) {
      autoRunOff=false; loopsDone++;
      // hide dog until the next loop or phase to avoid corner “flash”
      drawDogFlag = false;
      if (loopsDone < 3) {
        // run back in from the left (visible again)
        dog.x = -260; dog.dir=1; autoRunIn=true; setWalk(true);
        drawDogFlag = true;
      } else {
        // go to call-dad; keep dog hidden until scene swap completes
        setTimeout(()=> { drawDogFlag = true; startLevel1_CallDad(); }, 400);
      }
    }
  }
  if (autoRunIn){
    dog.x += (520*dt);
    if (dog.x >= 220){ autoRunIn=false; dog.state="sit"; showCenter("Press S to sniff for more treats", 4000); }
  }
}

function level1CallUpdate(dt){
  const speed=280*dt;
  if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
  else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
  else if (dog.state==="walk") dog.state="sit";
  dog.x = Math.max(40, Math.min(W-500, dog.x));

  if (!sfxLock && keys['b'] && !barkGate){
    barkGate=true; dog.state="howl";
    playSfx(sounds.bark, -4, 280, 1.0);
    setTimeout(()=> dog.state="sit", 140);
    callDadCount++; if (callDadCount<4) showCenter("I think dad heard that", 1200);
    setTimeout(()=> barkGate=false, 180);
  }
  if (!sfxLock && keys['h'] && !howlGate){
    howlGate=true; dog.state="howl";
    const h=(Math.random()<0.5)?sounds.howl1:sounds.howl2;
    playSfx(h, -8, 1600, 1.0);
    callDadCount++; if (callDadCount<4) showCenter("I think dad heard that", 1200);
    setTimeout(()=>{ howlGate=false; }, 520);
  }

  if (callDadCount>=4){
    callDadCount=-999;
    playExclusiveVO(sounds.letout, ()=> {
      try{ sounds.dooropen.currentTime=0; sounds.dooropen.volume=1.0; sounds.dooropen.play(); }catch{}
      setTimeout(()=> { bg = images["lvl1dooropen.png"]; }, 300);
      setTimeout(()=>{
        try{ sounds.rain.loop=true; sounds.rain.volume=0.9; sounds.rain.currentTime=0; sounds.rain.play(); }catch{}
        showCenter("Rain, I'm not going out there!", 4000);
      }, 600);
      setTimeout(()=>{
        setWalk(true); dog.dir=1;
        const run = setInterval(()=>{ dog.x += 40; }, 16);
        setTimeout(()=>{
          clearInterval(run);
          try{ sounds.rain.pause(); }catch{}
          // hide dog for a beat so there’s no corner flicker between scenes
          drawDogFlag = false;
          startLevel2();
        }, 1500);
      }, 1800);
    });
  }
}

function level2Update(dt){
  const speed=280*dt;
  if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
  else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
  else if (dog.state==="walk") dog.state="sit";
  dog.x = Math.max(40, Math.min(W-500, dog.x));

  if (!sfxLock && keys['b'] && !barkGate){
    barkGate=true; dog.state="howl";
    playSfx(sounds.bark, -4, 280, 1.0);
    setTimeout(()=> dog.state="sit", 140);
    actionCountL2++; showTooltip(`Keep going… (${actionCountL2}/8)`, 1200);
    setTimeout(()=> barkGate=false, 180);
  }
  if (!sfxLock && keys['h'] && !howlGate){
    howlGate=true; dog.state="howl";
    const h=(Math.random()<0.5)?sounds.howl1:sounds.howl2;
    playSfx(h, -8, 1600, 1.0);
    actionCountL2++; showTooltip(`Keep going… (${actionCountL2}/8)`, 1200);
    setTimeout(()=>{ howlGate=false; }, 520);
  }
  if (actionCountL2>=8){
    actionCountL2=-999;
    startFinal(); // final image + music; text fades in after 3s
  }
}

/* =========================
   Render & Loop
========================= */
function drawDog(){
  if (!drawDogFlag) return;
  if (dog.state==="walk") {
    dog.walkTimer += 1;
    if (dog.walkTimer >= (dog.walkSpeed? (dog.walkSpeed*100):10)) {
      dog.walkTimer = 0; dog.walkFrame = (dog.walkFrame+1)%3;
    }
  }
  let sprite = images["sit.png"];
  if (dog.state==="walk") sprite = images[ ["walk1.png","walk2.png","walk3.png"][dog.walkFrame] ];
  if (dog.state==="sniff") sprite = images["sniff1.png"];
  if (dog.state==="howl") sprite = images["howl.png"];

  ctx.save();
  if (dog.dir<0){ ctx.translate(dog.x + dog.w/2, 0); ctx.scale(-1,1); ctx.translate(-(dog.x + dog.w/2), 0); }
  ctx.drawImage(sprite, dog.x, dog.y, dog.w, dog.h);
  ctx.restore();
}
function drawTreat(){ if (!treatActive) return; const img = images[treatImg]; if (img) ctx.drawImage(img, treatX, treatY, 140, 100); }

let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  // Always fully paint the frame (pre-fill to avoid any “weird top” artefacts)
  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
  if (bg) ctx.drawImage(bg, 0, 0, W, H);

  if (scene==="splash") { /* splash bg + help card */ }
  else if (scene==="level1_sniff") { drawTreat(); drawDog(); level1SniffUpdate(dt); }
  else if (scene==="level1_call")  { drawDog(); level1CallUpdate(dt); }
  else if (scene==="level2")       { drawDog(); level2Update(dt); }
  else if (scene==="final")        { /* finalscreen drawn as bg; endText fades in */ }

  requestAnimationFrame(loop);
}

/* =========================
   Boot
========================= */
function drawOnce(){ ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H); if (bg) ctx.drawImage(bg,0,0,W,H); }

loadImages(imageFiles, ()=>{
  scene = "splash";
  bg = images["splashscreen.png"];
  splashHelp.style.display = "grid";
  drawOnce(); requestAnimationFrame(loop);

  // SPACE starts: play BGM, show intro video, then Level 1
  window.addEventListener('keydown', e=>{
    if (e.code === "Space" && scene === "splash") {
      splashHelp.style.display = "none";
      sounds.bgm.currentTime = 0; playBGM();
      const introWrap = document.getElementById('introWrap');
      const introVid  = document.getElementById('introVid');
      introWrap.style.display = "grid";
      introVid.currentTime = 0;
      introVid.play().catch(()=>{});
      introVid.onended = ()=>{ introWrap.style.display="none"; startLevel1(); };
      scene = "intro";
    }
  });
});
</script>
</body>
</html>
