<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Small Black Dog: Find My Sister</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --w:1920; --h:1080; }
  html, body { margin:0; height:100%; background:#000; }
  /* Center the game and scale it to fit the window (no cropping) */
  #stage {
    position: fixed; inset: 0;
    display: grid; place-items: center;
    background:#000;
  }
  canvas { width: var(--w)px; height: var(--h)px; background:#000; display:block; }
  /* Overlays */
  .ui {
    position: fixed; left:50%; transform:translateX(-50%);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:#fff; text-shadow: 2px 2px 2px rgba(0,0,0,.8);
    pointer-events:none; max-width: 80vw;
  }
  #bubble { top:10%; background:rgba(0,0,0,.45); padding:8px 12px; border-radius:10px; font-size:24px; display:none; }
  #tooltip { bottom:5%; background:rgba(0,0,0,.7); padding:8px 12px; border-radius:10px; font-size:20px; display:none; }
  #endText { top:50%; transform:translate(-50%,-50%); font-size:48px; opacity:0; transition:opacity 2s; }
  /* Splash instructions */
  #splashHelp {
    position: fixed; inset: 0; display:none; place-items:end center; padding:2rem;
    font: 18px system-ui; color:#fff; text-align:center; background: none; pointer-events:none;
    text-shadow: 2px 2px 2px rgba(0,0,0,.8);
  }
  #splashHelp .card{
    background: rgba(0,0,0,.55); padding:12px 16px; border-radius:12px; line-height:1.45;
  }
  /* Intro video overlay (muted, auto-plays after SPACE) */
  #introWrap {
    position: fixed; inset:0; display:none; place-items:center; background:#000;
  }
  #introWrap video {
    max-width: 100vw; max-height: 100vh; outline: none; border:none;
  }
</style>
</head>
<body>
<div id="stage">
  <canvas id="game" width="1920" height="1080"></canvas>
</div>

<!-- UI overlays -->
<div id="bubble" class="ui"></div>
<div id="tooltip" class="ui"></div>
<div id="endText" class="ui">No more howling for Sapphy</div>
<div id="splashHelp">
  <div class="card">
    <div style="font-size:22px;margin-bottom:6px;">Controls</div>
    <div><b>A / D</b> — Move • <b>S</b> — Sniff • <b>B</b> — Bark • <b>H</b> — Howl</div>
    <div style="opacity:.85;margin-top:6px;">Press <b>SPACE</b> to start</div>
  </div>
</div>

<!-- Intro video (plays after SPACE, then fades to Level 1). Muted so it will auto-play reliably. -->
<div id="introWrap">
  <video id="introVid" src="introvideo.mp4" poster="splashscreen.png" playsinline muted></video>
</div>

<script>
/* =========================
   Canvas + Fit-to-Window
========================= */
const W = 1920, H = 1080;
const stage = document.getElementById('stage');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function fit() {
  const sw = window.innerWidth, sh = window.innerHeight;
  const scale = Math.min(sw / W, sh / H);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', fit);
fit();

/* =========================
   UI helpers
========================= */
const bubbleEl = document.getElementById('bubble');
const tooltipEl = document.getElementById('tooltip');
const endTextEl = document.getElementById('endText');
const splashHelp = document.getElementById('splashHelp');

function showBubble(text, ms=2000) {
  bubbleEl.textContent = text; bubbleEl.style.display='block';
  if (ms) setTimeout(()=> bubbleEl.style.display='none', ms);
}
function showTooltip(text, ms=2000) {
  tooltipEl.textContent = text; tooltipEl.style.display='block';
  if (ms) setTimeout(()=> tooltipEl.style.display='none', ms);
}

/* =========================
   Assets
========================= */
const images = {};
const imageFiles = [
  "splashscreen.png", "lvl1.png", "lvl1dooropen.png", "lvl2.png", "finalscreen.png",
  "sit.png", "walk1.png", "walk2.png", "walk3.png", "sniff1.png", "howl.png",
  "treat1.png", "treat2.png"
];
function loadImages(files, cb){
  let left = files.length; if (!left) return cb();
  files.forEach(name=>{
    const img = new Image();
    img.onload = done; img.onerror = done; img.src = name; images[name]=img;
  });
  function done(){ if (--left===0) cb(); }
}

// Audio (case + spaces preserved)
const sounds = {
  bgm: new Audio(encodeURI("BGMUSIC.mp3")),
  final: new Audio(encodeURI("final music.mp3")),
  sniff1: new Audio(encodeURI("Sniff1.m4a")),
  sniff2: new Audio(encodeURI("sniff2.m4a")),
  bark: new Audio(encodeURI("bark1.m4a")),
  howl1: new Audio(encodeURI("howl1.m4a")),
  howl2: new Audio(encodeURI("howl2.m4a")),
  pickup: new Audio(encodeURI("treatpickup.m4a")),
  dooropen: new Audio(encodeURI("dooropen.wav")),
  knock: new Audio(encodeURI("door knock.wav")),
  letout: new Audio(encodeURI("letoutvoice.m4a")),
  rain: new Audio(encodeURI("rain.wav"))
};
sounds.bgm.loop = true; sounds.bgm.volume = 0.7;
sounds.final.loop = false;

/* =========================
   Input
========================= */
const keys = {};
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true );
window.addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false );

/* =========================
   Game State
========================= */
let scene = "splash";
let bg = null;

const dog = {
  x: 220, y: 680, w: 450, h: 400,
  state: "sit", dir: 1,
  walkFrame: 0, walkTimer: 0
};

let treatActive = false;
let treatX = 1200, treatY = 770, treatImg = "treat1.png";
let sniffPresses = 0;
let treatsCollected = 0;           // need 2–3 loops; we'll do 3
let autoSeek = false;              // move to treat
let autoRunOff = false;            // run to right edge
let actionCount = 0;               // level 2 sniff+bark counter
let level2ReadyForKnock = false;
let bgmPlaying = false;
let finalStartMs = 0;

/* =========================
   Audio Ducking
========================= */
const MUSIC_BASE = 0.7;
function duckBGM(dbDown, ms){
  const linear = Math.pow(10, dbDown/20); // dB -> linear
  const target = Math.max(0, Math.min(1, MUSIC_BASE * linear));
  const prev = sounds.bgm.volume;
  sounds.bgm.volume = target;
  setTimeout(()=> sounds.bgm.volume = MUSIC_BASE, (ms||350));
}
function playSfx(snd, duckDb=-4, holdMs=null){
  if (!snd) return;
  try {
    snd.currentTime = 0;
    const ms = holdMs ?? Math.max(200, (snd.duration||0.35)*1000);
    duckBGM(duckDb, ms+350);
    snd.play().catch(()=>{});
  }catch{}
}
function playBGM(){
  if (!bgmPlaying){
    sounds.bgm.play().then(()=> bgmPlaying=true).catch(()=>{});
  }
}
function stopBGM(){ try{ sounds.bgm.pause(); bgmPlaying=false; }catch{} }

/* =========================
   Scenes
========================= */
const introWrap = document.getElementById('introWrap');
const introVid  = document.getElementById('introVid');

function startSplash(){
  scene = "splash";
  bg = images["splashscreen.png"];
  splashHelp.style.display = "grid";
  draw(); // draw splash
}

function startIntroVideo(){
  // Play muted so it will auto-play; keep BGM running underneath
  introWrap.style.display = "grid";
  introVid.currentTime = 0;
  introVid.play().catch(()=>{ /* if blocked, user can click video to play */ });
  introVid.onended = ()=>{
    introWrap.style.display = "none";
    startLevel1();
  };
}

function startLevel1(){
  scene = "level1";
  bg = images["lvl1.png"];
  dog.x = 220; dog.y = 680; dog.state="sit"; dog.dir=1;
  treatActive = false; autoSeek = false; autoRunOff = false;
  sniffPresses = 0; treatsCollected = 0;
  showBubble("I can smell something good!", 1800);
  showTooltip("Press S to sniff", 2200);
}

function startLevel2(){
  scene = "level2";
  bg = images["lvl2.png"];
  try{ sounds.rain.pause(); }catch{}
  dog.x = 220; dog.y = 680; dog.state="sit"; dog.dir=1;
  actionCount = 0; level2ReadyForKnock = true;
  showTooltip("Sniff (S) or Bark (B) to get their attention", 2600);
}

function startFinal(){
  scene = "final";
  stopBGM();
  ctx.drawImage(images["finalscreen.png"],0,0,W,H);
  try{ sounds.final.currentTime=0; sounds.final.play(); }catch{}
  finalStartMs = performance.now();
}

/* =========================
   Level 1 Logic
========================= */
let sniffGate=false, barkGate=false, howlGate=false;

function spawnTreat(){
  // randomize treat and position on the floor
  treatImg = Math.random()<0.5 ? "treat1.png" : "treat2.png";
  treatX = Math.floor(400 + Math.random() * 900); // somewhere ahead
  treatY = 820; // floor level
  treatActive = true;
  autoSeek = true; // dog will walk to it
}

function pickupTreat(){
  treatActive = false;
  autoSeek = false;
  playSfx(sounds.pickup, -4);
  // start running off-screen, THEN trigger bubble after she's moving
  autoRunOff = true;
  setTimeout(()=> showBubble("I'll save this for later.", 1800), 250);
}

function level1Update(dt){
  // player movement (disabled during autoSeek/autoRunOff)
  const canMove = !autoSeek && !autoRunOff;
  if (canMove) {
    const speed = 280 * dt;
    if (keys['a']) { dog.x -= speed; dog.dir = -1; setWalk(); }
    else if (keys['d']) { dog.x += speed; dog.dir = 1; setWalk(); }
    else if (dog.state==="walk") dog.state="sit";
    dog.x = Math.max(40, Math.min(W-500, dog.x));
  }

  // sniff input (counts to 3 to spawn treat)
  if (keys['s'] && !sniffGate && canMove){
    sniffGate=true;
    dog.state="sniff";
    playSfx(Math.random()<0.5 ? sounds.sniff1 : sounds.sniff2, -4);
    sniffPresses++;
    setTimeout(()=>{ sniffGate=false; dog.state="sit"; }, 220);
    if (sniffPresses>=3 && !treatActive) {
      sniffPresses = 0;
      spawnTreat();
    }
  }

  // auto seek: walk to treat until overlap
  if (autoSeek && treatActive){
    const target = treatX - 80; // stop a bit before the treat center
    const dir = (dog.x < target) ? 1 : -1;
    dog.dir = dir;
    setWalk();
    const speed = 300 * dt;
    dog.x += speed * dir;
    if ((dir>0 && dog.x >= target) || (dir<0 && dog.x <= target)) {
      dog.state="sit";
      // "collide" with treat
      pickupTreat();
    }
  }

  // after pickup: run to the right edge, then return & reset or go to door
  if (autoRunOff){
    setWalk(true); // faster walk
    dog.dir = 1;
    dog.x += (460 * dt);
    if (dog.x > W + 100) {
      autoRunOff = false;
      treatsCollected++;
      if (treatsCollected < 3) {
        // return from left and prompt next sniff loop
        dog.x = -200;
        const slideIn = setInterval(()=>{ dog.x += 40; }, 16);
        setTimeout(()=>clearInterval(slideIn), 800);
        setTimeout(()=>{
          showBubble("I can smell something good!", 1600);
          showTooltip("Press S to sniff", 2000);
        }, 500);
      } else {
        // ready for the door
        showTooltip("Press H to howl", 2600);
      }
    }
  }

  // door sequence
  if (treatsCollected>=3 && keys['h'] && !howlGate){
    howlGate = true;
    dog.state="howl";
    const howl = (Math.random()<0.5)? sounds.howl1 : sounds.howl2;
    playSfx(howl, -8, 1600);
    setTimeout(()=> playSfx(sounds.letout, -8, 1100), 400);
    setTimeout(()=>{
      playSfx(sounds.dooropen, -6, 1000);
      bg = images["lvl1dooropen.png"];
    }, 800);
    setTimeout(()=>{
      try{ sounds.rain.loop=true; sounds.rain.volume=0.8; sounds.rain.currentTime=0; sounds.rain.play(); }catch{}
      showBubble("It's raining out there... I'm not going out there.", 2000);
    }, 1200);
    setTimeout(()=>{
      // slide off to the right, then load Level 2; stop rain on transition
      const slide = setInterval(()=>{ dog.x += 40; }, 16);
      setTimeout(()=>{
        clearInterval(slide);
        try{ sounds.rain.pause(); }catch{}
        startLevel2();
        howlGate=false; dog.state="sit";
      }, 1100);
    }, 2000);
  }
}

function setWalk(fast=false){
  if (dog.state!=="walk") { dog.state="walk"; dog.walkFrame=0; dog.walkTimer=0; }
  dog.walkSpeed = fast ? 0.06 : 0.1; // lower = faster cycle
}

/* =========================
   Level 2 Logic
========================= */
function level2Update(dt){
  // Player can still move around
  const speed = 280 * dt;
  if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
  else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
  else if (dog.state==="walk") dog.state="sit";
  dog.x = Math.max(40, Math.min(W-500, dog.x));

  // Sniff & Bark actions count toward the knock
  if (keys['s'] && !sniffGate){
    sniffGate=true;
    dog.state="sniff";
    playSfx(Math.random()<0.5 ? sounds.sniff1 : sounds.sniff2, -4);
    actionCount++;
    setTimeout(()=>{ sniffGate=false; dog.state="sit"; }, 220);
  }
  if (keys['b'] && !barkGate){
    barkGate=true;
    dog.state="howl"; // quick flicker to simulate bark
    playSfx(sounds.bark, -4, 250);
    setTimeout(()=> dog.state="sit", 120);
    actionCount++;
    setTimeout(()=> barkGate=false, 160);
  }

  if (level2ReadyForKnock && actionCount>=5){
    level2ReadyForKnock = false;
    playSfx(sounds.knock, -6, 1000);
    showBubble("Someone's at the door!", 2000);
    showTooltip("It's my favourite person! Press H to howl", 2600);
    scene = "level2_knock";
  }
}

function level2KnockUpdate(dt){
  // Movement allowed
  const speed = 280 * dt;
  if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
  else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
  else if (dog.state==="walk") dog.state="sit";
  dog.x = Math.max(40, Math.min(W-500, dog.x));

  if (keys['h'] && !howlGate){
    howlGate = true;
    dog.state = "howl";
    const howl = (Math.random()<0.5)? sounds.howl1 : sounds.howl2;
    playSfx(howl, -8, 1600);
    // Optional door open cue again
    setTimeout(()=> playSfx(sounds.dooropen, -6, 900), 400);
    setTimeout(()=> startFinal(), 600);
  }
}

/* =========================
   Final timing & fades
========================= */
function finalUpdate(){
  const t = (performance.now() - finalStartMs) / 1000;
  if (t>=30 && t<48){
    const k = (t-30)/18;
    ctx.fillStyle = `rgba(0,0,0,${k})`;
    ctx.fillRect(0,0,W,H);
  }
  if (t>=48){
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);
    endTextEl.style.opacity = 1;
  }
}

/* =========================
   Render
========================= */
function drawDog(){
  // Advance walk anim
  if (dog.state==="walk") {
    dog.walkTimer += 1;
    if (dog.walkTimer >= (dog.walkSpeed? (dog.walkSpeed*100):10)) {
      dog.walkTimer = 0;
      dog.walkFrame = (dog.walkFrame+1)%3;
    }
  }
  let sprite = images["sit.png"];
  if (dog.state==="walk") sprite = images[ ["walk1.png","walk2.png","walk3.png"][dog.walkFrame] ];
  if (dog.state==="sniff") sprite = images["sniff1.png"];
  if (dog.state==="howl") sprite = images["howl.png"];

  ctx.save();
  // flip if dir==-1
  if (dog.dir<0){
    ctx.translate(dog.x + dog.w/2, 0);
    ctx.scale(-1,1);
    ctx.translate(-(dog.x + dog.w/2), 0);
  }
  ctx.drawImage(sprite, dog.x, dog.y, dog.w, dog.h);
  ctx.restore();
}

function drawTreat(){
  if (!treatActive) return;
  const img = images[treatImg];
  if (img) ctx.drawImage(img, treatX, treatY, 140, 100);
}

/* =========================
   Main Loop
========================= */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  // background
  if (bg) ctx.drawImage(bg, 0, 0, W, H);
  else { ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H); }

  // scene updates + draws
  if (scene==="splash") {
    // splash drawn as bg (splashscreen.png), help card visible
  }
  else if (scene==="level1") {
    drawTreat();
    drawDog();
    level1Update(dt);
  }
  else if (scene==="level2") {
    drawDog();
    level2Update(dt);
  }
  else if (scene==="level2_knock") {
    drawDog();
    level2KnockUpdate(dt);
  }
  else if (scene==="final") {
    // finalscreen drawn when scene starts; just run fades
    finalUpdate();
  }

  requestAnimationFrame(loop);
}

/* =========================
   Boot
========================= */
loadImages(imageFiles, ()=>{
  // show splash
  scene = "splash";
  bg = images["splashscreen.png"];
  splashHelp.style.display = "grid";
  draw(); // first draw
  requestAnimationFrame(loop);

  // SPACE starts: play BGM, start intro video, then Level 1
  window.addEventListener('keydown', e=>{
    if (e.code === "Space" && scene === "splash") {
      splashHelp.style.display = "none";
      // start BGM (user gesture)
      playBGM();
      // play intro video, then go to level 1
      startIntroVideo();
      scene = "intro";
    }
  });
});

function draw(){ if (bg) ctx.drawImage(bg,0,0,W,H); }
</script>
</body>
</html>
