<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Small Black Dog: Find My Sister</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --w:1920; --h:1080; }
  html, body { margin:0; height:100%; background:#000; }
  /* Center the game and scale it to fit the window (no cropping) */
  #stage { position: fixed; inset: 0; display: grid; place-items: center; background:#000; }
  canvas { width: var(--w)px; height: var(--h)px; background:#000; display:block; }

  /* Overlays */
  .ui {
    position: fixed; left:50%; transform:translateX(-50%);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:#fff; text-shadow: 2px 2px 2px rgba(0,0,0,.85);
    pointer-events:none; max-width: 85vw;
  }
  #bubbleDog { position: fixed; display:none; font-size:24px; background:rgba(0,0,0,.45);
               padding:8px 12px; border-radius:10px; }
  #centerMsg { top: 48%; transform: translate(-50%,-50%); font-size: 46px; font-weight: 700;
               text-align:center; display:none; }
  #tooltip { bottom:5%; background:rgba(0,0,0,.7); padding:8px 12px; border-radius:10px; font-size:20px; display:none; }
  #endText { top:50%; transform:translate(-50%,-50%); font-size:48px; opacity:0; transition:opacity 2s; }

  /* Splash instructions */
  #splashHelp { position: fixed; inset: 0; display:none; place-items:end center; padding:2rem; }
  #splashHelp .card{
    background: rgba(0,0,0,.55); padding:14px 18px; border-radius:12px; line-height:1.45;
    font: 18px system-ui; color:#fff; text-align:center;
  }

  /* Intro video overlay (muted, auto-plays after SPACE) */
  #introWrap { position: fixed; inset:0; display:none; place-items:center; background:#000; }
  #introWrap video { max-width: 100vw; max-height: 100vh; outline: none; border:none; }
</style>
</head>
<body>
<div id="stage">
  <canvas id="game" width="1920" height="1080"></canvas>
</div>

<!-- UI overlays -->
<div id="bubbleDog" class="ui"></div>
<div id="centerMsg" class="ui"></div>
<div id="tooltip" class="ui"></div>
<div id="endText" class="ui">No more howling for Sapphy</div>
<div id="splashHelp">
  <div class="card">
    <div style="font-size:24px;margin-bottom:8px;">Small Black Dog: Find My Sister</div>
    <div style="margin-bottom:6px;"><b>A / D</b> — Move • <b>S</b> — Sniff • <b>B</b> — Bark • <b>H</b> — Howl</div>
    <div style="opacity:.9;">Press <b>SPACE</b> to start</div>
  </div>
</div>

<!-- Intro video -->
<div id="introWrap">
  <video id="introVid" src="introvideo.mp4" poster="splashscreen.png" playsinline muted></video>
</div>

<script>
/* =========================
   Canvas + Fit-to-Window
========================= */
const W = 1920, H = 1080;
const stage = document.getElementById('stage');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function fit() {
  const sw = window.innerWidth, sh = window.innerHeight;
  const scale = Math.min(sw / W, sh / H);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', fit);
fit();

/* =========================
   UI helpers
========================= */
const bubbleDog = document.getElementById('bubbleDog');
const centerMsg = document.getElementById('centerMsg');
const tooltipEl = document.getElementById('tooltip');
const endTextEl = document.getElementById('endText');
const splashHelp = document.getElementById('splashHelp');

function showCenter(text, ms=2000) {
  centerMsg.textContent = text; centerMsg.style.display='block';
  if (ms) setTimeout(()=> centerMsg.style.display='none', ms);
}
function showTooltip(text, ms=2000) {
  tooltipEl.textContent = text; tooltipEl.style.display='block';
  if (ms) setTimeout(()=> tooltipEl.style.display='none', ms);
}
// place bubble near dog
function showDogBubble(text, ms=1800) {
  bubbleDog.textContent = text;
  const r = canvas.getBoundingClientRect();
  const px = r.left + (dog.x + dog.w*0.5) * (r.width / W);
  const py = r.top + (dog.y - 30) * (r.height / H);
  bubbleDog.style.left = px + 'px';
  bubbleDog.style.top  = (py) + 'px';
  bubbleDog.style.transform = 'translate(-50%,-100%)';
  bubbleDog.style.display='block';
  if (ms) setTimeout(()=> bubbleDog.style.display='none', ms);
}

/* =========================
   Assets
========================= */
const images = {};
const imageFiles = [
  "splashscreen.png", "lvl1.png", "lvl1dooropen.png", "lvl2.png", "finalscreen.png",
  "sit.png", "walk1.png", "walk2.png", "walk3.png", "sniff1.png", "howl.png",
  "treat1.png", "treat2.png"
];
function loadImages(files, cb){
  let left = files.length; if (!left) return cb();
  files.forEach(name=>{
    const img = new Image();
    img.onload = done; img.onerror = done; img.src = name; images[name]=img;
  });
  function done(){ if (--left===0) cb(); }
}

// Audio (case + spaces preserved)
const sounds = {
  bgm: new Audio(encodeURI("BGMUSIC.mp3")),
  final: new Audio(encodeURI("final music.mp3")),
  sniff1: new Audio(encodeURI("Sniff1.m4a")),
  sniff2: new Audio(encodeURI("sniff2.m4a")),
  bark: new Audio(encodeURI("bark1.m4a")),
  howl1: new Audio(encodeURI("howl1.m4a")),
  howl2: new Audio(encodeURI("howl2.m4a")),
  pickup: new Audio(encodeURI("treatpickup.m4a")),
  dooropen: new Audio(encodeURI("dooropen.wav")),
  knock: new Audio(encodeURI("door knock.wav")), // not used in this version
  letout: new Audio(encodeURI("letoutvoice.m4a")),
  rain: new Audio(encodeURI("rain.wav"))
};
sounds.bgm.loop = true; sounds.bgm.volume = 0.7;
sounds.final.loop = false;

/* =========================
   Input
========================= */
const keys = {};
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true );
window.addEventListener('keyup',   e=> keys[e.key.toLowerCase()] = false );

/* =========================
   Game State
========================= */
let scene = "splash";
let bg = null;

const dog = {
  x: 220, y: 680, w: 450, h: 400,
  state: "sit", dir: 1,
  walkFrame: 0, walkTimer: 0, walkSpeed: 0.1
};

let treatActive = false;
let treatX = 1200, treatY = 820, treatImg = "treat1.png";
let sniffPresses = 0;
let loopsDone = 0;                 // treat loops (2–3); we’ll do 3
let autoSeek = false;              // walk to treat
let autoRunOff = false;            // run to right edge
let autoRunIn = false;             // run in from left
let callDadCount = 0;              // L1: bark+howl required
let actionCountL2 = 0;             // L2: bark+howl required (7–8); we’ll do 8
let bgmPlaying = false;
let finalStartMs = 0;

let sniffGate=false, barkGate=false, howlGate=false;

/* =========================
   Audio Ducking
========================= */
const MUSIC_BASE = 0.7;
function duckBGM(dbDown, ms){
  const linear = Math.pow(10, dbDown/20); // dB -> linear
  const target = Math.max(0, Math.min(1, MUSIC_BASE * linear));
  sounds.bgm.volume = target;
  setTimeout(()=> sounds.bgm.volume = MUSIC_BASE, (ms||350));
}
function playSfx(snd, duckDb=-4, holdMs=null, volOverride=null){
  if (!snd) return;
  try {
    if (volOverride!==null) snd.volume = volOverride;
    snd.currentTime = 0;
    const ms = holdMs ?? Math.max(200, (snd.duration||0.35)*1000);
    duckBGM(duckDb, ms+350);
    snd.play().catch(()=>{});
  }catch{}
}
function playBGM(){
  if (!bgmPlaying){
    sounds.bgm.play().then(()=> bgmPlaying=true).catch(()=>{});
  }
}
function stopBGM(){ try{ sounds.bgm.pause(); bgmPlaying=false; }catch{} }

/* =========================
   Scenes
========================= */
const introWrap = document.getElementById('introWrap');
const introVid  = document.getElementById('introVid');

function startSplash(){
  scene = "splash";
  bg = images["splashscreen.png"];
  splashHelp.style.display = "grid";
  draw();
}

function startIntroVideo(){
  introWrap.style.display = "grid";
  introVid.currentTime = 0;
  introVid.play().catch(()=>{});
  introVid.onended = ()=>{
    introWrap.style.display = "none";
    startLevel1();
  };
}

function startLevel1(){
  scene = "level1_sniff";
  bg = images["lvl1.png"];
  Object.assign(dog, { x: 220, y: 680, state:"sit", dir:1, walkFrame:0, walkTimer:0 });
  treatActive = autoSeek = autoRunOff = autoRunIn = false;
  sniffPresses = 0; loopsDone = 0; callDadCount = 0;
  showCenter("I can smell something good!", 1600);
  showCenter("Press S to sniff for more treats", 2400);
}

function startLevel1_CallDad(){
  scene = "level1_call";
  callDadCount = 0;
  showCenter("Sapphy wants to go outside", 2200);
  showTooltip("Bark (B) or Howl (H) a few times", 2600);
}

function startLevel2(){
  scene = "level2";
  bg = images["lvl2.png"];
  try{ sounds.rain.pause(); }catch{}
  Object.assign(dog, { x: 220, y: 680, state:"sit", dir:1, walkFrame:0, walkTimer:0 });
  actionCountL2 = 0;
  showCenter("Where is my favourite person, I should bark!", 2600);
  showTooltip("Bark (B) or Howl (H) 8 times", 3000);
}

function startFinal(){
  scene = "final";
  stopBGM();
  ctx.drawImage(images["finalscreen.png"],0,0,W,H);
  try{ sounds.final.currentTime=0; sounds.final.play(); }catch{}
  finalStartMs = performance.now();
}

/* =========================
   Treat Flow Helpers
========================= */
function setWalk(fast=false){
  if (dog.state!=="walk") { dog.state="walk"; dog.walkFrame=0; dog.walkTimer=0; }
  dog.walkSpeed = fast ? 0.06 : 0.1; // lower = faster cycle
}
function spawnTreatAwayFromDog(){
  // spawn 300–700px to the right (clamped), different image alternative
  treatImg = Math.random()<0.5 ? "treat1.png" : "treat2.png";
  const minOffset = 300, maxOffset = 700;
  let x = dog.x + (minOffset + Math.random()*(maxOffset-minOffset));
  x = Math.max(380, Math.min(W-500, x));
  treatX = Math.floor(x);
  treatY = 820;
  treatActive = true;
  autoSeek = true;
}
function pickupTreat(){
  treatActive = false;
  autoSeek = false;
  playSfx(sounds.pickup, -4);
  autoRunOff = true;                    // start running off
  setTimeout(()=> showDogBubble("I'll save this for later.", 1600), 220);
}

/* =========================
   Level Updates
========================= */
function level1SniffUpdate(dt){
  // movement
  const canMove = !autoSeek && !autoRunOff && !autoRunIn;
  const speed = 280 * dt;
  if (canMove) {
    if (keys['a']) { dog.x -= speed; dog.dir = -1; setWalk(); }
    else if (keys['d']) { dog.x += speed; dog.dir = 1; setWalk(); }
    else if (dog.state==="walk") dog.state="sit";
    dog.x = Math.max(40, Math.min(W-500, dog.x));
  }

  // sniff input (3 presses → treat spawns away from dog)
  if (keys['s'] && !sniffGate && canMove){
    sniffGate=true;
    dog.state="sniff";
    playSfx(Math.random()<0.5 ? sounds.sniff1 : sounds.sniff2, -4);
    sniffPresses++;
    setTimeout(()=>{ sniffGate=false; dog.state="sit"; }, 220);
    if (sniffPresses>=3 && !treatActive) {
      sniffPresses = 0;
      spawnTreatAwayFromDog();
    }
  }

  // auto seek to treat
  if (autoSeek && treatActive){
    const target = treatX - 80;
    const dir = (dog.x < target) ? 1 : -1;
    dog.dir = dir; setWalk();
    dog.x += (300*dt) * dir;
    if ((dir>0 && dog.x >= target) || (dir<0 && dog.x <= target)) {
      dog.state="sit";
      pickupTreat();
    }
  }

  // run off right, then run back in from left (running, not sitting), and show big prompt
  if (autoRunOff){
    setWalk(true); dog.dir = 1; dog.x += (480*dt);
    if (dog.x > W + 120) {
      autoRunOff = false;
      loopsDone++;
      if (loopsDone < 3) {
        // run back in from the left
        dog.x = -260; dog.dir = 1; autoRunIn = true; setWalk(true);
      } else {
        // move to call-dad phase
        setTimeout(()=> startLevel1_CallDad(), 350);
      }
    }
  }
  if (autoRunIn){
    dog.x += (520*dt);
    if (dog.x >= 220) {
      autoRunIn = false; dog.state="sit";
      showCenter("Press S to sniff for more treats", 2200);
    }
  }
}

function level1CallUpdate(dt){
  // movement allowed
  const speed = 280 * dt;
  if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
  else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
  else if (dog.state==="walk") dog.state="sit";
  dog.x = Math.max(40, Math.min(W-500, dog.x));

  // Bark / Howl a few times (need 4 total)
  if (keys['b'] && !barkGate){
    barkGate=true;
    dog.state="howl";
    playSfx(sounds.bark, -4, 250);
    setTimeout(()=> dog.state="sit", 120);
    callDadCount++;
    if (callDadCount<4) showCenter("I think dad heard that", 1000);
    setTimeout(()=> barkGate=false, 160);
  }
  if (keys['h'] && !howlGate){
    howlGate=true;
    dog.state="howl";
    const h = (Math.random()<0.5)? sounds.howl1 : sounds.howl2;
    playSfx(h, -8, 1600);
    callDadCount++;
    if (callDadCount<4) showCenter("I think dad heard that", 1000);
    setTimeout(()=> { howlGate=false; }, 500);
  }

  if (callDadCount>=4){
    // success sequence: loud let-out voice, door open, bg swap, rain, big text, run off to Level 2
    callDadCount = -999; // prevent repeats
    // voice (louder)
    playSfx(sounds.letout, -8, 1400, 1.0);
    setTimeout(()=> playSfx(sounds.dooropen, -6, 1000), 400);
    setTimeout(()=> { bg = images["lvl1dooropen.png"]; }, 700);
    setTimeout(()=>{
      try{ sounds.rain.loop=true; sounds.rain.volume=0.8; sounds.rain.currentTime=0; sounds.rain.play(); }catch{}
      showCenter("Rain, I'm not going out there!", 2200);
    }, 1000);
    setTimeout(()=>{
      // sprint off right
      setWalk(true); dog.dir=1;
      const run = setInterval(()=>{ dog.x += 40; }, 16);
      setTimeout(()=>{
        clearInterval(run);
        try{ sounds.rain.pause(); }catch{}
        startLevel2();
      }, 1300);
    }, 2200);
  }
}

function level2Update(dt){
  // movement
  const speed = 280 * dt;
  if (keys['a']) { dog.x -= speed; dog.dir=-1; setWalk(); }
  else if (keys['d']) { dog.x += speed; dog.dir= 1; setWalk(); }
  else if (dog.state==="walk") dog.state="sit";
  dog.x = Math.max(40, Math.min(W-500, dog.x));

  // Bark / Howl 8 times total
  if (keys['b'] && !barkGate){
    barkGate=true;
    dog.state="howl";
    playSfx(sounds.bark, -4, 250);
    setTimeout(()=> dog.state="sit", 120);
    actionCountL2++;
    showTooltip(`Keep going… (${actionCountL2}/8)`, 900);
    setTimeout(()=> barkGate=false, 160);
  }
  if (keys['h'] && !howlGate){
    howlGate=true;
    dog.state="howl";
    const h = (Math.random()<0.5)? sounds.howl1 : sounds.howl2;
    playSfx(h, -8, 1600);
    actionCountL2++;
    showTooltip(`Keep going… (${actionCountL2}/8)`, 1000);
    setTimeout(()=> { howlGate=false; }, 500);
  }

  if (actionCountL2>=8){
    actionCountL2 = -999;
    // optional door cue again
    setTimeout(()=> playSfx(sounds.dooropen, -6, 900), 200);
    setTimeout(()=> startFinal(), 500);
  }
}

/* =========================
   Final timing & fades
========================= */
function finalUpdate(){
  const t = (performance.now() - finalStartMs) / 1000;
  if (t>=30 && t<48){
    const k = (t-30)/18;
    ctx.fillStyle = `rgba(0,0,0,${k})`;
    ctx.fillRect(0,0,W,H);
  }
  if (t>=48){
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);
    endTextEl.style.opacity = 1;
  }
}

/* =========================
   Render
========================= */
function drawDog(){
  // Advance walk anim
  if (dog.state==="walk") {
    dog.walkTimer += 1;
    if (dog.walkTimer >= (dog.walkSpeed? (dog.walkSpeed*100):10)) {
      dog.walkTimer = 0;
      dog.walkFrame = (dog.walkFrame+1)%3;
    }
  }
  let sprite = images["sit.png"];
  if (dog.state==="walk") sprite = images[ ["walk1.png","walk2.png","walk3.png"][dog.walkFrame] ];
  if (dog.state==="sniff") sprite = images["sniff1.png"];
  if (dog.state==="howl") sprite = images["howl.png"];

  ctx.save();
  if (dog.dir<0){
    ctx.translate(dog.x + dog.w/2, 0);
    ctx.scale(-1,1);
    ctx.translate(-(dog.x + dog.w/2), 0);
  }
  ctx.drawImage(sprite, dog.x, dog.y, dog.w, dog.h);
  ctx.restore();
}

function drawTreat(){
  if (!treatActive) return;
  const img = images[treatImg];
  if (img) ctx.drawImage(img, treatX, treatY, 140, 100);
}

/* =========================
   Main Loop
========================= */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;

  // background
  if (bg) ctx.drawImage(bg, 0, 0, W, H);
  else { ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H); }

  // scene updates + draws
  if (scene==="splash") {
    // drawn as bg; help card visible
  }
  else if (scene==="level1_sniff") {
    drawTreat(); drawDog(); level1SniffUpdate(dt);
  }
  else if (scene==="level1_call") {
    drawDog(); level1CallUpdate(dt);
  }
  else if (scene==="level2") {
    drawDog(); level2Update(dt);
  }
  else if (scene==="final") {
    finalUpdate();
  }

  requestAnimationFrame(loop);
}

/* =========================
   Boot
========================= */
const introWrap = document.getElementById('introWrap');
const introVid  = document.getElementById('introVid');

loadImages(imageFiles, ()=>{
  // show splash
  scene = "splash";
  bg = images["splashscreen.png"];
  splashHelp.style.display = "grid";
  draw(); requestAnimationFrame(loop);

  // SPACE starts: play BGM, play intro video, then Level 1
  window.addEventListener('keydown', e=>{
    if (e.code === "Space" && scene === "splash") {
      splashHelp.style.display = "none";
      playBGM();
      startIntroVideo();
      scene = "intro";
    }
  });
});

function draw(){ if (bg) ctx.drawImage(bg,0,0,W,H); }
</script>
</body>
</html>
